package edu.brown.cs.cocker.analysis;

import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import org.eclipse.jdt.core.dom.ASTNode;
import org.eclipse.jdt.core.dom.CompilationUnit;
import edu.brown.cs.cocker.analysis.rebase.*;
import edu.brown.cs.cocker.util.*;


public class AnalysisCodeWordGenerator implements AnalysisConstants, AnalysisConstants.PatternTokenizer {

    protected int k_value; //Not actually used.
    protected static RebaseWordStemmer stemmer;
    protected static boolean filter_stopwords = true;
    protected static boolean filter_short_and_long_words = true;

    static { stemmer = new RebaseWordStemmer(); }

    //It seems the constructor is unneeded.
    public AnalysisCodeWordGenerator(Object k0) {
	k_value = 5;
	if (k0 != null && k0 instanceof Number) {
	    int k = ((Number) k0).intValue();
	    if (k > 0) k_value = k;
	}
    }

    public void setFilterStopWords(boolean true_or_false) {
	filter_stopwords = true_or_false;
    }

    public boolean stopWordsFiltered() {
	return filter_stopwords;
    }

    public void setFilterShortAndLongWords(boolean true_or_false) {
	filter_short_and_long_words = true_or_false;
    }

    public boolean shortAndLongWordsFiltered() {
	return filter_short_and_long_words;
    }
    
    
    /* 
       getTokens first parses an AST node into a list of so-called code tokens.
       Next it invokes getTokensHelper to obtain words from these tokens.
       Words are generated by RebaseWordFactory by applying a set of modifications to
       the code tokens (filtering, splitting, casting to lower-case, and stemming).
       getTokens wraps the words as a list of PatternTokens and returns it.
    */
    
    @Override public List<PatternToken> getTokens(ASTNode node) {
	CodeTokenGenerator ctgen = new CodeTokenGenerator();
	return getTokensHelper(ctgen.getCTs(node, -1));
    }

    @Override public List<PatternToken> getTokens(List<ASTNode> node_list) {
	CodeTokenGenerator ctgen = new CodeTokenGenerator();
	List<CodeToken> ct_list = new ArrayList<CodeToken>();
	for (ASTNode node : node_list) {
	    List<CodeToken> ct_list0 = ctgen.getCTs(node, -1);
	    for (CodeToken ct0 : ct_list0) { ct_list.add(ct0); }
	}
	return getTokensHelper(ct_list);
    }
    
    @Override public List<PatternToken> getTokens(ASTNode node, String data) {
	CodeTokenGenerator ctgen = new CodeTokenGenerator();
	if (!(node instanceof CompilationUnit)) { return getTokens(node); }
	CompilationUnit cu = (CompilationUnit) node;
	List<QueryNode> qnode_list = QueryNodeFinder.find(cu, data);
	Map<ASTNode, Integer> property_map = new HashMap<ASTNode, Integer>();
	for (QueryNode qnode : qnode_list) {
	    ASTNode qnode_node = qnode.getNode();
	    if (qnode_node != null) {
		property_map.put(qnode_node, qnode.getProp());
	    }
	}
	ctgen.setPropertyMap(property_map);

	List<CodeToken> ct_list0 = new ArrayList<CodeToken>();
	for (QueryNode qnode : qnode_list) {
	    if (qnode.isNested()) { continue; }
	    ASTNode qnode_node = qnode.getNode();
	    List<CodeToken> ct_list1 = ctgen.getCTs(qnode_node, qnode.getProp());
	    for (CodeToken ct1 : ct_list1) { ct_list0.add(ct1); }
	}
	List<PatternToken> pt_list = getTokensHelper(ct_list0);
	return pt_list;
    }
    
    @Override public List<PatternToken> getTokens(String cnts) {
	//For indexing, subclasses overwrite this.
	return new ArrayList<PatternToken>();
    }

    //This method gets words from the list of code tokens and wraps them as pattern tokens.
    protected List<PatternToken> getTokensHelper(List<CodeToken> ct_list) {
	int pos = 0;
	List<PatternToken> pt_list = new ArrayList<PatternToken>();
	for (CodeToken ct : ct_list) {
	    int prop = ct.getProp();
	    String ct_text = ct.getText();
	    List<String> stemmed_words = stem(ct_text);
	    for (String stemmed_word : stemmed_words) {
		PatternToken pt = new CodeWord(stemmed_word, pos);
		pt.setProp(prop);
		pos++;
		pt_list.add(pt);
	    }
	}
	return pt_list;
    }

    /* Extract the rebase words from cnts. */
    public static List<String> stem(String cnts) {
	List<String> token_list = new ArrayList<String>();
	int size = cnts.length();
	for (int i = 0; i < size; ++i) {
	    char ch = cnts.charAt(i);
	    if (Character.isJavaIdentifierPart(ch)) {
		boolean havealpha = Character.isAlphabetic(ch);
		int start = i;
		while (Character.isJavaIdentifierPart(ch)) {
		    havealpha |= Character.isAlphabetic(ch);
		    if (++i >= size) break;
		    ch = cnts.charAt(i);
		}
		//If the token has alpha, then it is a name
		if (havealpha) {
		    List<String> token_sublist = RebaseWordFactory.getCandidateWords(stemmer, cnts, start, i-start, filter_stopwords, filter_short_and_long_words);
		    if (token_sublist != null) {
			for (String token : token_sublist) {
			    token_list.add(token);
			}
		    }
		}
	    }
	}
	return token_list;
    }
    
    static class CodeWord implements PatternToken {
    
        private String word_text;
        private int    word_pos;
        private int    word_prop;
    
        CodeWord(String text, int pos) {
            this.word_text = text;
            this.word_pos = pos;
            word_prop = -1;
        }
    
        @Override public String getText() {
            return word_text;
        }
    
        @Override public int getPosition() {
            return word_pos;
        }
    
        @Override public void setPosition(int pos) {
            this.word_pos = pos;
        }
        
        @Override public String toString() {
            return word_text + "@" + word_pos;
        }
    
        @Override public int getProp() {
            return word_prop;
        }
    
        @Override public void setProp(int prop) {
            this.word_prop = prop;
        }
    }
}
